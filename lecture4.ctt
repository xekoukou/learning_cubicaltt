{-
            Lecture 4 on cubicaltt (Cubical Type Theory)
--------------------------------------------------------------------------
                        Anders MÃ¶rtberg

Contents:
  o Equivalences
  o Glue types
  o Univalence

-}
module lecture4 where

import lecture3

--------------------------------------------------------------------------
-- Equivalences

-- For more results about equivalences see chapter 4 of the HoTT book.

-- The fiber/preimage of a map:
fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B y (f x)

-- A map is an equivalence
isEquiv (A B : U) (f : A -> B) : U =
  (y : B) -> isContr (fiber A B f y)

equiv (A B : U) : U = (f : A -> B) * isEquiv A B f

-- Recall:
-- contrSingl (A : U) (a b : A) (p : Path A a b) :
--            Path (singl A a) (a,<i> a) (b,p) =

-- The identity function is an equivalence
idIsEquiv (A : U) : isEquiv A A (idfun A) =
  \(a : A) -> ((a,<i> a),
         \(z : fiber A A (idfun A) a) -> contrSingl A a z.1 z.2)

idEquiv (A : U) : equiv A A = (idfun A,idIsEquiv A)

-- Compute the inverse of an equivalence
invEquiv (A B : U) (e : equiv A B) (y : B) : A =
  (e.2 y).1.1

-- Exercises (easy): the inverse is really the inverse
retEq (A B : U) (e : equiv A B) (y : B) : Path B (e.1 (invEquiv A B e y)) y = <i> (e.2 y).1.2 @ -i
secEq (A B : U) (e : equiv A B) (x : A) : Path A (invEquiv A B e (e.1 x)) x = <i> (((e.2 (e.1 x)).2 (x , <j> e.1 x)) @ i).1

-- Exercise (hard): prove that being contractible is a proposition.
-- (hint: use a composition)
lem11 (A : U) (c : isContr A) (x : A) : Path (isContr A) (c.1,(\(y : A) -> transit A c.1 c.1 y (<j> c.1) (c.2 y))) (x , (\(y : A) -> transit A x c.1 y (<i> (c.2 x) @ -i) (c.2 y)))
  = <i> comp (<_> isContr A) ((c.2 x) @ i , (\(y : A) -> transit A ((c.2 x) @ i) c.1 y (<j> (c.2 x) @ (-j /\ i)) (c.2 y)))
      [ (i = 0) -> <j> (c.1, (\(y : A) -> transit A c.1 c.1 y (<j> c.1) (c.2 y)))
      , (i = 1) -> <j> (x , (\(y : A) -> transit A x c.1 y (<l> (c.2 x) @ -l) (c.2 y))) ]


-- One contraction can be transported into a different location.
lem1 (A : U) (c : isContr A) (x : A) : Path (isContr A) c (x , (\(y : A) -> transit A x c.1 y (<i> (c.2 x) @ -i) (c.2 y)))
  = subst ((y : A) -> Path A c.1 y)
    (\(z : (y : A) -> Path A c.1 y) -> Path (isContr A) (c.1, z) (x , (\(y : A) -> transit A x c.1 y (<i> (c.2 x) @ -i) (c.2 y))))
    (\(y : A) -> (transit A c.1 c.1 y (<j> c.1) (c.2 y))) c.2 (<i> (\(y : A) -> (transitId A c.1 y (c.2 y)) @ i)) (lem11 A c x)


-- Two contractions at the same location are homotopy equivalent.

lem2 (A : U) (x : A) (f g : (y : A) -> Path A x y) : Path (isContr A) (x , f) (x , g)
  = <i> (x , \(y : A) -> (propSet A (isContrProp A (x , f)) x y (f y) (g y)) @ i)



isPropIsContr (A : U) : isProp (isContr A) = (\(c1 c2 : isContr A) -> transit (isContr A) c1 (c2.1 , (\(y : A) -> transit A c2.1 c1.1 y (<i> (c1.2 c2.1) @ -i) (c1.2 y))) c2 (lem1 A c1 c2.1) (lem2 A c2.1 (\(y : A) -> transit A c2.1 c1.1 y (<i> (c1.2 c2.1) @ -i) (c1.2 y)) c2.2) )

